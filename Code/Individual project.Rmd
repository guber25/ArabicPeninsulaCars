---
output:
  html_document: default
  pdf_document: default
---
# STATISTICAL LEARNING INDIVIDUAL PROJECT

## Master's Degree in Data Science for Economics
## Universit√† degli Studi di Milano

### Author: Guglielmo Berzano

##### October 2023


```{r}
library(tidyverse) #increases R dictionary
library(magrittr) #increases R dictionary
library(reshape2)
library(Hmisc)
library(ggpubr)
library(corrplot) #creation of the correlation plot
library(car)
library(leaps) #best subset
library(robustbase) #robust regression
library(olsrr) #chart for residuals
library(rpart) #regression trees
library(rpart.plot) #plotting regression trees
library(randomForest) #random forest algorithm
library(caret)
library(ggfortify) #pca plotting
library(factoextra)#pca plotting
library(rgl) #3d plots for PCA, just for fun
```

```{r}
me_cars<- read.csv("https://raw.githubusercontent.com/guber25/ArabicPeninsulaCars/main/Dataset/Car%20in%20the%20middle%20east.csv")
head(me_cars)
```

### DATA PREPROCESSING

```{r}

#Filtering out the null values
me_cars<-me_cars %>% filter(price != " TBD " &
                              Cylinders != "N/A" &
                              Trunk.Capacity..liters. != "N/A" &
                              Trunk.Capacity..liters. != "Null")


#Changing the type of some columns (from char to dbl) and removing strange values

me_cars$price <- gsub(",", "", me_cars$price) %>% as.numeric() %>% round(2)

me_cars$Cylinders <- as.numeric(me_cars$Cylinders)

me_cars$Trunk.Capacity..liters. <- gsub(" \\(.*\\)", "", me_cars$Trunk.Capacity..liters.) %>% as.numeric()

me_cars$Fuel.Tank.Capacity..liters. <- gsub(" \\(.*\\)", "",me_cars$Fuel.Tank.Capacity..liters.) %>% as.numeric()

me_cars$Seating.Capacity <- gsub("Seater", "",me_cars$Seating.Capacity) %>% as.numeric()

me_cars$Wheelbase..meters.<- gsub("  ", "", me_cars$Wheelbase..meters.) %>% as.numeric() %>% round(2)

me_cars$Torque..Nm.  %<>%  as.numeric

me_cars$Length..meters. %<>% round(2)

me_cars$Width..meters. %<>% round(2)

me_cars$Height..meters. %<>% round(2)

#Changing the type of other columns (from char to fact)

me_cars$Drive.Type %<>% as.factor
me_cars$Fuel.Type %<>% as.factor
me_cars$Transmission %<>% as.factor
me_cars$currency %<>% as.factor

#Renaming some variables so that they are easier to understand

me_cars <- me_cars %>% rename("Engine_Capacity"="Engine.Capacity..liters.",
                              "Driving"="Drive.Type",
                              "Fuel_Capacity"="Fuel.Tank.Capacity..liters.",
                              "Liters_For_100km"="Fuel.Economy..L.100.Km.",
                              "Fuel_Type"="Fuel.Type",
                              "Horsepower"="Horsepower..bhp.",
                              "Torque"="Torque..Nm.",
                              "Top_Speed"="Top.Speed..Km.h.",
                              "Seating_Capacity"="Seating.Capacity",
                              "Acceleration_0100"="Acceleration.0.100.Km.h..sec.",
                              "Length"="Length..meters.",
                              "Width"="Width..meters.",
                              "Height"="Height..meters.",
                              "Wheelbase"="Wheelbase..meters.",
                              "Trunk_Capacity"="Trunk.Capacity..liters.",
                              "Price"="price",
                              "Currency"="currency",
                              "Name"="name")


#EXCHANGE RATES RETRIEVED ON JUNE, FRIDAY 23th
me_cars$PriceEURO<-ifelse(me_cars$Currency=="SAR", me_cars$Price*.25,
                          ifelse(me_cars$Currency=="AED", me_cars$Price*.25,
                                 ifelse(me_cars$Currency=="BHD", me_cars$Price*2.44,
                                        ifelse(me_cars$Currency=="KWD", me_cars$Price*2.99,
                                               ifelse(me_cars$Currency=="OMR", me_cars$Price*2.39, me_cars$Price*.25)))))

#Creating the column Area
me_cars$Area<-ifelse(me_cars$Currency=="SAR", "Saudi Arabia",
                          ifelse(me_cars$Currency=="AED", "UAE",
                                 ifelse(me_cars$Currency=="BHD", "Bahrain",
                                        ifelse(me_cars$Currency=="KWD", "Kuwait",
                                               ifelse(me_cars$Currency=="OMR", "Oman", "Qatar")))))
me_cars$Area %<>% as.factor
me_cars %>% head()
```


Map for first page of the report

```{r}
mec_map0 <- data.frame(region=c("Bahrain", "Kuwait", "Qatar", "Oman", "Saudi Arabia", "United Arab Emirates"),
                       column=c(seq(1,6,1)))

mapdata<-map_data("world")
mapdata <- left_join(mapdata, mec_map0, by="region") 
mapdata<-mapdata %>% filter(!is.na(mapdata$column))

ggplot(mapdata, aes(x=long, y=lat, group=group))+
  
  geom_polygon(aes(fill=region), col="black")+
  scale_fill_manual(name="Countries", breaks=c("Bahrain", "Kuwait", "Oman", "Qatar", "Saudi Arabia", "United Arab Emirates"),
    values=c("azure","skyblue", "deepskyblue", "dodgerblue", "blue3", "navy"))+

  
  theme(plot.title = element_text(face="bold"),
    axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks = element_blank(),
        axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        rect = element_blank())
```

### DATA EXPLORATION

```{r}
me_cars %>% select(-Driving,-Fuel_Type,-Transmission,-Name,-Currency,-Area,-Price) %>% gather() %>% 
  ggplot(aes(value)) + 
    geom_boxplot(fill="skyblue", color="black", outlier.colour = "deepskyblue") + 
    facet_wrap(~key, scales = 'free')+
  theme_minimal()
```

It is clear that there are a lot of outliers. It is important to remove the most extreme ones.
The criterion used to decide which is an outlier and which is not is just common sense, i.e. it is impossible that a car is 4500m long.

### Outlier removal

```{r}

value = me_cars[,"Height"][me_cars[,"Height"]>500]
me_cars[,"Height"][me_cars[,"Height"] %in% value] = NA
me_cars = drop_na(me_cars)

value = me_cars[,"Length"][me_cars[,"Length"]>500]
me_cars[,"Length"][me_cars[,"Length"] %in% value] = NA
me_cars = drop_na(me_cars)

value = me_cars[,"Wheelbase"][me_cars[,"Wheelbase"]>500]
me_cars[,"Wheelbase"][me_cars[,"Wheelbase"] %in% value] = NA
me_cars = drop_na(me_cars)

value = me_cars[,"Width"][me_cars[,"Width"]>500]
me_cars[,"Width"][me_cars[,"Width"] %in% value] = NA
me_cars = drop_na(me_cars)

value = me_cars[,"Horsepower"][me_cars[,"Horsepower"]>1250]
me_cars[,"Horsepower"][me_cars[,"Horsepower"] %in% value] = NA
me_cars = drop_na(me_cars)


value = me_cars[,"Trunk_Capacity"][me_cars[,"Trunk_Capacity"]>1300]
me_cars[,"Trunk_Capacity"][me_cars[,"Trunk_Capacity"] %in% value] = NA
me_cars = drop_na(me_cars)

value = me_cars[,"PriceEURO"][me_cars[,"PriceEURO"]>750000]
me_cars[,"PriceEURO"][me_cars[,"PriceEURO"] %in% value] = NA
me_cars = drop_na(me_cars)

#REMOVE DUPLICATES
me_cars %<>% distinct() 
```


```{r}
me_cars %>% select(-Driving,-Fuel_Type,-Transmission,-Name,-Currency, -Price, -Area) %>% gather() %>% 
  ggplot(aes(value)) + 
geom_boxplot(fill="skyblue", color="black", outlier.colour = "deepskyblue") + 
    facet_wrap(~key, scales = 'free')+
  theme_minimal()
```
```{r}
me_cars %>% select(-Driving,-Fuel_Type,-Transmission,-Name,-Currency, -Area, -Price) %>% gather() %>% 
  ggplot(aes(value)) +
geom_histogram(fill="skyblue", color="black") + 
    facet_wrap(~key, scales = 'free')+
  theme_minimal()
```

Now we have obtained a nice dataset to work with.


```{r}
me_cars %>% select(-Driving,-Fuel_Type,-Transmission,-Name,-Currency,-Price, -Area) %>% cor() %>% corrplot(type = "full", 
         tl.col = "black", tl.srt = 45)
```

We see how many variables are quite correlated with each other. This correlation will be better analysed later.

We plot a chart of the correlation between numeric variables and PriceEURO


```{r}
pr_cor<-me_cars %>% select(-Driving,-Fuel_Type,-Transmission,-Name,-Currency,-Price, -Area) %>% cor() %>% data.frame()
pr_cor<-pr_cor[-15,]
ggplot(pr_cor, aes(x=pr_cor %>% rownames(), y=PriceEURO))+
  geom_bar(fill=ifelse(pr_cor$PriceEURO>0,"deepskyblue","red") ,stat="identity")+
  labs(x="\nVariables",
       y="Correlation with PriceEURO")+
  guides(x =  guide_axis(angle = 45))+
  theme(axis.text = element_text(face="bold"),
        panel.background = element_rect(fill = "white",
                                colour = "white"),
        panel.grid.major = element_line(linewidth = 0.01, linetype = 'solid',
                                colour = "gray88"))
```

## SUPERVISED LEARNING

#### Tests for normality and linear regression

```{r}
me_cars %>% 
  ggplot(aes(PriceEURO)) +
  geom_density(linewidth=1)+
  theme_minimal()
```

Not normal at all. We try to take the log

```{r}
me_cars %>% 
  ggplot(aes(log(PriceEURO))) +
  geom_density(linewidth=1)+
  stat_overlay_normal_density(color="red", linetype="dashed", linewidth=1)+
  theme_minimal()
```

Much better than before! Let's try to make statistical tests on this.

To do so we are going to create a new dataset called "mec_stat", meaning Middle East Cars Stat without some of the useless variable we had in the original dataset.

Then we create a ds for each of the 5 Areas, namely:
- Bahrain (BR)
- Kuwait (KW)
- Oman (OM)
- Qatar (QT)
- Saudi Arabia (SA)
- United Arab Emirates (UAE)

```{r}
mec_stat<-me_cars %>% select(-Name,-Price, -Currency) #general ds for statistical analysis

#a bit naive but necessary
mec_statSA <- mec_stat %>% filter(Area=="Saudi Arabia") %>% select(-Area)
mec_statUAE <- mec_stat %>% filter(Area=="UAE") %>% select(-Area)
mec_statBR <- mec_stat %>% filter(Area=="Bahrain") %>% select(-Area)
mec_statOM <- mec_stat %>% filter(Area=="Oman") %>% select(-Area)
mec_statQT <- mec_stat %>% filter(Area=="Qatar") %>% select(-Area)
mec_statKW <- mec_stat %>% filter(Area=="Kuwait") %>% select(-Area)
```


```{r}
mec_map1 <- data.frame(region=c("Bahrain", "Kuwait", "Qatar", "Oman", "Saudi Arabia", "United Arab Emirates"),
                       AvgPrice=c(mean((mec_statBR$PriceEURO)),
                                  mean((mec_statKW$PriceEURO)),
                                  mean((mec_statQT$PriceEURO)),
                                  mean((mec_statOM$PriceEURO)),
                                  mean((mec_statSA$PriceEURO)),
                                  mean((mec_statUAE$PriceEURO))))

mapdata<-map_data("world")
mapdata <- left_join(mapdata, mec_map1, by="region") 
mapdata<-mapdata %>% filter(!is.na(mapdata$AvgPrice))

ggplot(mapdata, aes(x=long, y=lat, group=group))+
  geom_polygon(aes(fill=AvgPrice), color="black")+
  scale_fill_gradient(name="Average car price in EURO\n", low="#CCFFFF", high="#000066",
                      #ticks for the legend
                      limit=c(min(mapdata$AvgPrice), max(mapdata$AvgPrice)),
                      breaks=seq(from=round(min(mapdata$AvgPrice)), 
                                 to=max(mapdata$AvgPrice),
                            by=round((max(mapdata$AvgPrice)-round(min(mapdata$AvgPrice)))/4,2)))+
  
  theme(axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks = element_blank(),
        axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        rect = element_blank())
```

We now take the Shapiro-Wilk test to verify whether the distribution of the variables is normal or not.

```{r}
cat("Bahrain")
shapiro.test(log(mec_statBR$PriceEURO))
cat("\nKuwait")
shapiro.test(log(mec_statKW$PriceEURO))
cat("\nQatar")
shapiro.test(log(mec_statQT$PriceEURO))
cat("\nOman")
shapiro.test(log(mec_statOM$PriceEURO))
cat("\nSaudi Arabia")
shapiro.test(log(mec_statSA$PriceEURO))
cat("\nUnited Arab Emirates")
shapiro.test(log(mec_statUAE$PriceEURO))
```

We can see that, apart from Oman, all the other distributions are not-gaussian.
So we check for the distribution over the residuals which, by the way, is the important distribution to check for making inference with ols.

```{r}
model1BR=mec_statBR %>% lm(log(PriceEURO)~.,.)
cat("\nBahrain")
shapiro.test(model1BR$residuals)

model1KW=mec_statKW %>% lm(log(PriceEURO)~.,.)
cat("\nKuwait")
shapiro.test(model1KW$residuals)

model1OM=mec_statOM %>% lm(log(PriceEURO)~.,.)
cat("\nOman")
shapiro.test(model1OM$residuals)

model1QT=mec_statQT %>% lm(log(PriceEURO)~.,.)
cat("\nQatar")
shapiro.test(model1QT$residuals)

model1SA=mec_statSA %>% lm(log(PriceEURO)~.,.)
cat("\nSaudi Arabia")
shapiro.test(model1SA$residuals)

model1UAE=mec_statUAE %>% lm(log(PriceEURO)~.,.)
cat("\nUnited Arab Emirates")
shapiro.test(model1UAE$residuals)
```

We see that Kuwait, Oman and UAE have normally distributed error while the other countries have not. In order to be consistent with the analysis I decided not to consider the linear regression since not all the results where unbiased.


#### Further analysis is needed

Now we initialize a function for computing the Vif (variance inflation factor) and for plotting its values.

```{r}
# VIF FUNCTION

vif_func<-function(model_name, country){
  modelvif=data.frame(vif(model_name)) #we compute the vif of the model
  modelvif$row=row.names(modelvif) #we do some magic to let R know what we are working with
  colnames(modelvif)[1] = "Vif"
  
  
  #Plotting the Vif
  modelvif %>%
  ggplot(aes(row, Vif))+
  geom_bar(stat="identity")+
  geom_hline(yintercept = 5, linewidth=1, color="yellow")+
  geom_hline(yintercept = 7.5, linewidth=1, color="orange")+
  geom_hline(yintercept = 10, linewidth=1, color="red")+
  scale_y_continuous(limits = c(0,30), breaks = seq(0,30,2.5), minor_breaks = NULL)+
  labs(x=NULL, y=NULL, title = bquote(paste("Vif value per variable - Area: ",.(country))))+
  coord_flip()+
  theme_minimal()

}

```

We initialize also a function for obtaining the best subset possible.

```{r}
#BEST SUBSET MODEL
best_sub<-function(ds,country){
  best_sub<-regsubsets(x= log(PriceEURO)~.,data = ds, nvmax = length(names(ds)), 
                       method = "forward") #we do the subset
  best_sub_summary<- best_sub %>% summary()
  best_sub_summary$cp %>% which.min()
  plot(best_sub, scale="Cp") #we plot the best one
  title(main=country)
}
```

We do again the regression for convenience.

```{r}
model1BR=mec_statBR %>% lm(log(PriceEURO)~.,.,)
model1KW=mec_statKW %>% lm(log(PriceEURO)~.,.)
model1QT=mec_statQT %>% lm(log(PriceEURO)~.,.)
model1OM=mec_statOM %>% lm(log(PriceEURO)~.,.)
model1SA=mec_statSA %>% lm(log(PriceEURO)~.,.)
model1UAE=mec_statUAE %>% lm(log(PriceEURO)~.,.)
```

First we check the Vif for all the models and...

```{r}
vif_func(model1BR,"Bahrain")
vif_func(model1KW,"Kuwait")
vif_func(model1QT,"Qatar")
vif_func(model1OM,"Oman")
vif_func(model1SA,"Saudi Arabia")
vif_func(model1UAE,"United Arab Emirates")
```

... we eliminate the most correlated variables:

```{r}
mec_statBR <- mec_statBR %>% select(-Horsepower, -Engine_Capacity)
mec_statKW <- mec_statKW %>% select(-Horsepower, -Engine_Capacity)
mec_statQT <- mec_statQT %>% select(-Horsepower, -Engine_Capacity)
mec_statSA <- mec_statSA %>% select(-Horsepower, -Engine_Capacity)
mec_statOM <- mec_statOM %>% select(-Horsepower, -Engine_Capacity)
mec_statUAE <- mec_statUAE %>% select(-Length, -Horsepower,-Engine_Capacity)
```

Now, with the leftover variables, we compute the best possible subset for each model and...

```{r}
mec_statBR %>% best_sub("Bahrain")
mec_statKW %>% best_sub("Kuwait")
mec_statQT %>% best_sub("Qatar")
mec_statOM %>% best_sub("Oman")
mec_statSA %>% best_sub("Saudi Arabia")
mec_statUAE %>% best_sub("UAE")
```

... again we remove the non-important ones and create some dummies if necessary. To be clear, the non-important variables are the ones that at the top of the chart have a white rectangle.

```{r}
#Selecting only the important variables

#BAHRAIN
mec_statBR <- mec_statBR %>% select(-Transmission)

#KUWAIT
mec_statKW <- mec_statKW %>% select(-c(Acceleration_0100, Length))

#QATAR
mec_statQT$TransMan <-ifelse(mec_statQT$Transmission=="Manual",1,0)
mec_statQT <- mec_statQT %>% select(-Transmission, -Fuel_Type, -Length)

#OMAN
mec_statOM$FT_Hybrid <-ifelse(mec_statOM$Fuel_Type=="Hybrid",0,1)
mec_statOM <- mec_statOM %>% select(-Length, -Transmission, -Fuel_Type)

#Saudi Arabia
mec_statSA$DrivingFWD <-ifelse(mec_statSA$Driving=="Front Wheel Drive",1,0)
mec_statSA <- mec_statSA %>% select(-Driving, -Transmission, Width)

#United Arab Emirates
mec_statUAE$DrivingFWD <-ifelse(mec_statUAE$Driving=="Front Wheel Drive",1,0)
mec_statUAE$FT_Hybrid <-ifelse(mec_statUAE$Fuel_Type=="Hybrid",1,0)
mec_statUAE <- mec_statUAE %>% select(-Driving,-Fuel_Type,-Transmission)
```

We now retrain the linear model with the new datasets

```{r}
model1BR=mec_statBR %>% lm(log(PriceEURO)~.,.,)
model1KW=mec_statKW %>% lm(log(PriceEURO)~.,.)
model1OM=mec_statOM %>% lm(log(PriceEURO)~.,.)
model1QT=mec_statQT %>% lm(log(PriceEURO)~.,.)
model1SA=mec_statSA %>% lm(log(PriceEURO)~.,.)
model1UAE=mec_statUAE %>% lm(log(PriceEURO)~.,.)
```

Check again the Vif and notice that things got way better.

```{r}
vif_func(model1BR,"Bahrain")
vif_func(model1KW,"Kuwait")
vif_func(model1OM,"Oman")
vif_func(model1QT,"Qatar")
vif_func(model1SA,"Saudi Arabia")
vif_func(model1UAE,"UAE")
```

Now we have cleaned the dataset as much as possible. We don't have variables that suffer from multicollinearity and we have selected the best subset of variables, this seems perfect!!

What about using the robust regression since...

```{r}
ols_plot_resid_lev(model1KW)
```

... there are so many outliers?

Initializing a function to compute the robust regression. We are not scaling the variable PriceEURO and we are removing, if present, the variable DrivingFWD because it was giving problems.

```{r}
rob_reg<-function(ds){
  set.seed(1)
  index <- sample(2, nrow(ds), prob = c(0.8, 0.2), replace = TRUE) 
  #so we give to each observation a prob of 80% of falling into the train and 20% of falling into the test
  
  PriceEURO<-ds$PriceEURO

  ds<-ds %>% select(where(is.numeric), -PriceEURO) %>% scale() %>% data.frame() %>% cbind(PriceEURO)
  
  Train <- ds[index==1, ] # Train data
  Test <- ds[index == 2, ] #Test data
  model1<- Train %>% lmrob(log(PriceEURO)~.,.)
  predicted<-predict(model1, newdata=Test)
  cat("\nR¬≤: ", 
      1-(
        (sum((log(Test$PriceEURO)-predicted)^2))/
          (sum((log(Test$PriceEURO)-mean(log(Test$PriceEURO)))^2))),"\n")
  model1 %>% summary() %>% print()
  model1$coefficients %>% sort(decreasing = TRUE)
}
```

From the following cell it is possible to retrieve the most influent variables in the model by looking among the significant ones at those with the highest coefficient in absolute value.


```{r}
cat("BAHRAIN:")
mec_statBR %>% rob_reg()
cat("\n\nKUWAIT:")
mec_statKW  %>% rob_reg()
cat("\n\nOMAN:")
mec_statOM %>% rob_reg()
cat("\n\nQatar:")
mec_statQT %>% rob_reg()
cat("\n\nSAUDI ARABIA")
mec_statSA %>% rob_reg()
cat("\n\nUAE:")
mec_statUAE %>% rob_reg()
```

```{r}
#Storing the value of the R2 of the robust regression
R2rr<-c(0.8886621,
0.8531936,
0.8713075,
0.8709802,
0.8458653,
0.8914368)
```

```{r}
mec_map5 <- data.frame(region=c("Bahrain", "Kuwait", "Oman", "Qatar", "Saudi Arabia", "United Arab Emirates"),
                       R2rr=R2rr)

mapdata<-map_data("world")
mapdata <- left_join(mapdata, mec_map5, by="region") 
mapdata<-mapdata %>% filter(!is.na(mapdata$R2rr))

ggplot(mapdata, aes(x=long, y=lat, group=group))+
  geom_polygon(aes(fill=R2rr), color="black")+
  scale_fill_gradient(name="R¬≤ for Robust Regression\n", low="#CCFFFF", high="#000066",
                      limit=c(.84, .90),
                      breaks=seq(from=.84,
                                 to=.90,
                            by=.01))+
  
  theme(axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks = element_blank(),
        axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        rect = element_blank())
```


### TREES
Since neither the linear nor the robust linear model were good, for a reason or another, we could try with regression trees. 


--- Notice that we are doing first a single regression tree before doing the random forest

```{r}
tree_constructor <- function(ds) { #this function works only with rpart objects
  set.seed(1)
  index <- sample(2, nrow(ds), prob = c(0.8, 0.2), replace = TRUE) #so we give to each observation a prob of 80% of falling into the train and 20% of falling into the test

  Train <- ds[index==1, ] # Train data
  Test <- ds[index == 2, ] #Test data
  model1<- Train %>% rpart(log(PriceEURO)~.,., method="anova", model = TRUE) 
  #we use anova because we are doing regression
  
  
  cp <- which.min(model1$cptable[, "xerror"]) %>% model1$cptable[., "CP"]
  #we select the min value of the column xerror of the cptable (where cp stands for the cost of pruning )
  
  
  model1_pr <- prune(tree = model1, cp =cp)
  model1_pr %>% rpart.plot(roundint = TRUE, digits = 4, left=FALSE)
  
  predicted<-predict(model1_pr, newdata=Test)
  cat("\nThe MSE is:",mean(predicted-log(Test$PriceEURO))^2,"\n")

cat("\nR¬≤: ", 
      1-(
        (sum((log(Test$PriceEURO)-predicted)^2))/
          (sum((log(Test$PriceEURO)-mean(log(Test$PriceEURO)))^2))),"\n")
print(data.frame(model1_pr$variable.importance))
  return(1-(
        (sum((log(Test$PriceEURO)-predicted)^2))/
          (sum((log(Test$PriceEURO)-mean(log(Test$PriceEURO)))^2))))

}
```


We can now see the best single tree for each country


```{r}
R2Tree<- c(tree_constructor(mec_statBR), #create a variable R2Tree for the Rsquared
tree_constructor(mec_statKW),
tree_constructor(mec_statOM),
tree_constructor(mec_statQT),
tree_constructor(mec_statSA),
tree_constructor(mec_statUAE))
```



```{r}
mec_map2 <- data.frame(region=c("Bahrain", "Kuwait", "Oman", "Qatar", "Saudi Arabia", "United Arab Emirates"),
                       R2Tree=R2Tree)

mapdata<-map_data("world")
mapdata <- left_join(mapdata, mec_map2, by="region") 
mapdata<-mapdata %>% filter(!is.na(mapdata$R2Tree))

ggplot(mapdata, aes(x=long, y=lat, group=group))+
  geom_polygon(aes(fill=R2Tree), color="black")+
  scale_fill_gradient(name="R¬≤ for Regression Trees\n", low="#CCFFFF", high="#000066",
                      limit=c(.70, .90),
                      breaks=seq(from=.70,
                                 to=.90,
                            by=.04))+
  
  theme(axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks = element_blank(),
        axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        rect = element_blank())
```

Not bad but this is the worst model obtained so far.

### Random Forest algorithm

```{r}
rf_model <- function(ds, country) {
  set.seed(1)
  
  index <- sample(2, nrow(ds), prob = c(0.8, 0.2), replace = TRUE) #so we give to each observation a prob of 80% of falling into the train and 20% of falling into the test

  Train <- ds[index==1, ] # Train data
  Test <- ds[index==2, ]
  
  ##### BEST MTRY #####
  
  # Define the cross validation
  control <- trainControl(method = "cv",  
                        number = 10,  #number of folds
                        search = "random")  

  grid <- data.frame(mtry = c(2, 3, 4))  # 

  # train the model
  best_mtry_model <- train(log(PriceEURO) ~ .,  
                      data = Train, 
                      method = "rf", 
                      trControl = control,
                      tuneGrid=grid)
  
  cat("\nThe best nr of mtry for min error is: ", best_mtry_model$bestTune[1,1])
  
  ##### BEST NTREE #####
  
  tree_nr <- seq(from= 50, to= 500, by=50)  # number of trees to test

  MSE_train<-c()
  
  for (i in 1:length(tree_nr)) {
    
    model_rf <- randomForest(log(PriceEURO) ~ ., data = Train, ntree = tree_nr[i],
                             mtry=best_mtry_model$bestTune[1,1])
    
    MSE_train<-append(MSE_train, model_rf$mse[i]) #append the mse to the vector
  }


# MSE error minimizer
best_ntree <- min(MSE_train[MSE_train<0.09 & MSE_train>0.04]) %>% match(MSE_train) %>% tree_nr[.] #best_ntree is the number such that the MSE is within 0.05 and 0.09 to avoid overfitting. These values have been found thanks to empirical tests
  
  
  cat("\nThe best nr of trees for min error is: ", best_ntree)
  
  
  
  rf1=randomForest(log(PriceEURO)~.,
                   data=Train,
                   ntree=best_ntree,
                   mtry=best_mtry_model$bestTune[1,1],
                   importance=TRUE)
  
  print(rf1) 
  plot(rf1, main=country)
  varImpPlot(rf1, main=country)
  
    yhat <- predict(rf1,newdata = Test)
  plot (yhat , Test$PriceEURO %>% log(), xlab="Predicted ln(Price)",ylab = "Actual ln(Price)", main=country)
  
  abline (0, 1, col="red")
  cat("Mean squared error: ",mean(yhat - log(Test$PriceEURO))^2)
  cat("\nR¬≤: ", 
      1-(
        (sum((log(Test$PriceEURO)-yhat)^2))/
        (sum((log(Test$PriceEURO)-mean(log(Test$PriceEURO)))^2))))
}
```


```{r}
#NEW
rf_model(mec_statBR, "Bahrain")
```



```{r}
#NEW
rf_model(mec_statKW, "Kuwait")
```

```{r}
#NEW
rf_model(mec_statOM, "Oman")
```

```{r}
#NEW
rf_model(mec_statQT, "Qatar")
```

```{r}
#NEW
rf_model(mec_statSA, "Saudi Arabia")
```

```{r}
#NEW
rf_model(mec_statUAE, "United Arab Emirates")
```


```{r}
R2rf<-c(0.9458579, 0.9260215,0.9434955, 0.9389488, 0.9077597, 0.9359294)

mec_map3 <- data.frame(region=c("Bahrain", "Kuwait", "Qatar", "Oman", "Saudi Arabia", "United Arab Emirates"),
                       R2rf=R2rf)

mapdata<-map_data("world")
mapdata <- left_join(mapdata, mec_map3, by="region") 
mapdata<-mapdata %>% filter(!is.na(mapdata$R2rf))

ggplot(mapdata, aes(x=long, y=lat, group=group))+
  geom_polygon(aes(fill=R2rf), color="black")+
  scale_fill_gradient(name="R¬≤ for Random Forest\n", low="#CCFFFF", high="#000066",
                      limit=c(.90, .95),
                      breaks=seq(from=.90,
                                 to=.95,
                            by=.01))+
  
  theme(axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks = element_blank(),
        axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        rect = element_blank())
```

The random forest is clearly the best model even though it is a bit slow.

```{r}
R2df<-left_join(mec_map2,mec_map3, by="region")
R2df$R2rr<-R2rr

R2best_Tr_rr<-c()
for (i in (1:6)){
  
  if (R2df[i,2]>R2df[i,4]){
    
  R2best_Tr_rr[i]<-"Regression Tree"
  } else if (R2df[i,2]==R2df[i,4]) {
    R2best_Tr_rr[i]<-"Tie"
  }else {
      R2best_Tr_rr[i]<-"Robust Regression"
  }
  
  }
  
R2df$R2best_Tr_rr<-R2best_Tr_rr

R2df$R2best_Tr_rr %<>% as.factor
R2df
```

In this map we are comparing R2 to see which is the highest

```{r}
mapdata<-map_data("world")
mapdata <- left_join(mapdata, R2df, by="region") 
mapdata<-mapdata %>% filter(!is.na(mapdata$R2best_Tr_rr))

ggplot(mapdata, aes(x=long, y=lat, group=group))+
  geom_polygon(aes(fill=R2best_Tr_rr), color="white")+
    scale_fill_manual(name="Best model according to R¬≤:\n",labels=c("Robust Regression", "Regression Tree","Tie"),
                      values=c( "#000066", "#CCFFFF", "lightgrey"))+
  theme(axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks = element_blank(),
        axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        rect = element_blank())
```




## UNSUPERVISED LEARNING

For this section I decided to use the PCA. Since the PCA works better with correlated variables, I decided to restore the original datasets, excluding just the variable Area

```{r}
mec_statSA2 <- mec_stat %>% filter(Area=="Saudi Arabia") %>% select(-Area)
mec_statUAE2 <- mec_stat %>% filter(Area=="UAE") %>% select(-Area)
mec_statBR2 <- mec_stat %>% filter(Area=="Bahrain") %>% select(-Area)
mec_statQT2 <- mec_stat %>% filter(Area=="Qatar") %>% select(-Area)
mec_statOM2 <- mec_stat %>% filter(Area=="Oman") %>% select(-Area)
mec_statKW2 <- mec_stat %>% filter(Area=="Kuwait") %>% select(-Area)
```


```{r}
mec_statSA2 %>% glimpse() #for example
```

Some data cleaning not to have categorical variables


```{r}
#BAHRAIN
mec_statBR2$DrivingFWD <- ifelse(mec_statBR2$Driving=="Front Wheel Drive", 1,0)
mec_statBR2$DrivingAWD <- ifelse(mec_statBR2$Driving=="All Wheel Drive", 1,0)
mec_statBR2$DrivingRWD <- ifelse(mec_statBR2$Driving=="Rear Wheel Drive", 1,0)
mec_statBR2$TransMan <- ifelse(mec_statBR2$Transmission=="Manual", 1,0)
mec_statBR2$TransCVT <- ifelse(mec_statBR2$Transmission=="CVT", 1,0)
mec_statBR2$TransAuto <- ifelse(mec_statBR2$Transmission=="Automatic", 1,0)
mec_statBR2$FTHybr <- ifelse(mec_statBR2$Fuel_Type=="Hybrid", 1,0)
mec_statBR2$FTPetr <- ifelse(mec_statBR2$Fuel_Type=="Petrol", 1,0)
mec_statBR2$FTDiesel <- ifelse(mec_statBR2$Fuel_Type=="Diesel", 1,0)
mec_statBR2 <- mec_statBR2 %>% select(-c(Driving, Transmission, Fuel_Type, PriceEURO))

#KUWAIT
mec_statKW2$DrivingFWD <- ifelse(mec_statKW2$Driving=="Front Wheel Drive", 1,0)
mec_statKW2$DrivingAWD <- ifelse(mec_statKW2$Driving=="All Wheel Drive", 1,0)
mec_statKW2$DrivingRWD <- ifelse(mec_statKW2$Driving=="Rear Wheel Drive", 1,0)
mec_statKW2$TransMan <- ifelse(mec_statKW2$Transmission=="Manual", 1,0)
mec_statKW2$TransCVT <- ifelse(mec_statKW2$Transmission=="CVT", 1,0)
mec_statKW2$TransAuto <- ifelse(mec_statKW2$Transmission=="Automatic", 1,0)
mec_statKW2$FTHybr <- ifelse(mec_statKW2$Fuel_Type=="Hybrid", 1,0)
mec_statKW2$FTPetr <- ifelse(mec_statKW2$Fuel_Type=="Petrol", 1,0)
mec_statKW2$FTDiesel <- ifelse(mec_statKW2$Fuel_Type=="Diesel", 1,0)
mec_statKW2 <- mec_statKW2 %>% select(-c(Driving, Transmission, Fuel_Type, PriceEURO))

#QATAR
mec_statQT2$DrivingFWD <- ifelse(mec_statQT2$Driving=="Front Wheel Drive", 1,0)
mec_statQT2$DrivingAWD <- ifelse(mec_statQT2$Driving=="All Wheel Drive", 1,0)
mec_statQT2$DrivingRWD <- ifelse(mec_statQT2$Driving=="Rear Wheel Drive", 1,0)
mec_statQT2$TransMan <- ifelse(mec_statQT2$Transmission=="Manual", 1,0)
mec_statQT2$TransCVT <- ifelse(mec_statQT2$Transmission=="CVT", 1,0)
mec_statQT2$TransAuto <- ifelse(mec_statQT2$Transmission=="Automatic", 1,0)
mec_statQT2$FTHybr <- ifelse(mec_statQT2$Fuel_Type=="Hybrid", 1,0)
mec_statQT2$FTPetr <- ifelse(mec_statQT2$Fuel_Type=="Petrol", 1,0)
mec_statQT2$FTDiesel <- ifelse(mec_statQT2$Fuel_Type=="Diesel", 1,0)
mec_statQT2 <- mec_statQT2 %>% select(-c(Driving, Transmission, Fuel_Type, PriceEURO))

#OMAN
mec_statOM2$DrivingFWD <- ifelse(mec_statOM2$Driving=="Front Wheel Drive", 1,0)
mec_statOM2$DrivingAWD <- ifelse(mec_statOM2$Driving=="All Wheel Drive", 1,0)
mec_statOM2$DrivingRWD <- ifelse(mec_statOM2$Driving=="Rear Wheel Drive", 1,0)
mec_statOM2$TransMan <- ifelse(mec_statOM2$Transmission=="Manual", 1,0)
mec_statOM2$TransCVT <- ifelse(mec_statOM2$Transmission=="CVT", 1,0)
mec_statOM2$TransAuto <- ifelse(mec_statOM2$Transmission=="Automatic", 1,0)
mec_statOM2$FTHybr <- ifelse(mec_statOM2$Fuel_Type=="Hybrid", 1,0)
mec_statOM2$FTPetr <- ifelse(mec_statOM2$Fuel_Type=="Petrol", 1,0)
mec_statOM2$FTDiesel <- ifelse(mec_statOM2$Fuel_Type=="Diesel", 1,0)
mec_statOM2 <- mec_statOM2 %>% select(-c(Driving, Transmission, Fuel_Type, PriceEURO))

#SAUDI ARABIA
mec_statSA2$DrivingFWD <- ifelse(mec_statSA2$Driving=="Front Wheel Drive", 1,0)
mec_statSA2$DrivingAWD <- ifelse(mec_statSA2$Driving=="All Wheel Drive", 1,0)
mec_statSA2$DrivingRWD <- ifelse(mec_statSA2$Driving=="Rear Wheel Drive", 1,0)
mec_statSA2$TransMan <- ifelse(mec_statSA2$Transmission=="Manual", 1,0)
mec_statSA2$TransCVT <- ifelse(mec_statSA2$Transmission=="CVT", 1,0)
mec_statSA2$TransAuto <- ifelse(mec_statSA2$Transmission=="Automatic", 1,0)
mec_statSA2$FTHybr <- ifelse(mec_statSA2$Fuel_Type=="Hybrid", 1,0)
mec_statSA2$FTPetr <- ifelse(mec_statSA2$Fuel_Type=="Petrol", 1,0)
mec_statSA2$FTDiesel <- ifelse(mec_statSA2$Fuel_Type=="Diesel", 1,0)
mec_statSA2 <- mec_statSA2 %>% select(-c(Driving, Transmission, Fuel_Type, PriceEURO))

#UNITED ARAB EMIRATES
mec_statUAE2$DrivingFWD <- ifelse(mec_statUAE2$Driving=="Front Wheel Drive", 1,0)
mec_statUAE2$DrivingAWD <- ifelse(mec_statUAE2$Driving=="All Wheel Drive", 1,0)
mec_statUAE2$DrivingRWD <- ifelse(mec_statUAE2$Driving=="Rear Wheel Drive", 1,0)
mec_statUAE2$TransMan <- ifelse(mec_statUAE2$Transmission=="Manual", 1,0)
mec_statUAE2$TransCVT <- ifelse(mec_statUAE2$Transmission=="CVT", 1,0)
mec_statUAE2$TransAuto <- ifelse(mec_statUAE2$Transmission=="Automatic", 1,0)
mec_statUAE2$FTHybr <- ifelse(mec_statUAE2$Fuel_Type=="Hybrid", 1,0)
mec_statUAE2$FTPetr <- ifelse(mec_statUAE2$Fuel_Type=="Petrol", 1,0)
mec_statUAE2$FTDiesel <- ifelse(mec_statUAE2$Fuel_Type=="Diesel", 1,0)
mec_statUAE2 <- mec_statUAE2 %>% select(-c(Driving, Transmission, Fuel_Type, PriceEURO))
```


Pca 3D plot for fun:

```{r}
pcatest <- mec_statBR2 %>% prcomp(scale. = TRUE, center = TRUE)

#3D plot just for fun, not rendered in the html document unfortunately
scores=pcatest$x[,1:3] %>% as.data.frame()
plot3d(scores)

text3d(pcatest$rotation[,1:3]*1000, 
       texts=rownames(pcatest$rotation), 
       col="red", 
       cex=0.8)
 

coords <- c()
for (i in 1:nrow(pcatest$rotation)) {
  coords <- rbind(coords, rbind(c(0,0,0),pcatest$rotation[i,1:3]))
}
 
lines3d(coords*1000, 
        col="orange", 
        lwd=1)
```


PCA function: 

Here we apply the Principal component analysis and we select up to the 7th principal component which is the last one with eigenvalues > 1 meaning that each principal component explains at least as much information as one column in the original datasets.

```{r}
pca<- function(ds, country){
  pca1 <- ds %>% prcomp(scale. = TRUE, center = TRUE)
    
    var <- pca1 %>% get_pca_var()
    
  corplot<-corrplot(var$cor[,1:7], is.corr = FALSE, col.lim = c(-1,1),cl.align.text = "l",tl.col = "black" )
  

  contrib<-pca1 %>% fviz_contrib(choice = "var", axes = 1)+ggtitle(paste("Contribution of variables to 1st Principal component - ",country))

    pca1 %>% fviz_pca_var(col.var = pca1$rotation[,3], repel = TRUE)+
    ggtitle(paste(country, " PCA"))+
    scale_color_gradient2(name="Correlation with\nthe third component",limits=c(-1,1), low="red3",mid="deepskyblue",high="navy") #circle correlation plot 
    
    return(contrib)
}
```


PCA results:


```{r}
pca(mec_statBR2, "Bahrain")
pca(mec_statKW2, "Kuwait")
pca(mec_statOM2, "Oman")
pca(mec_statQT2, "Qatar")
pca(mec_statSA2, "Saudi Arabia")
pca(mec_statUAE2, "United Arab Emirates")
```


```{r}
pr_lm <- function(ds_pc,ds_original, request="default"){
  
  if (is.element("PriceEURO", ds_pc %>% colnames())){
    PriceEURO<- ds_pc$PriceEURO
    ds_pc$PriceEURO<-NULL
  }
  
  #PC computation
  pc<-ds_pc %>% prcomp(scale. = TRUE, center=TRUE)
  sign_var<-pc$sdev %>% data.frame() %>% filter(.>1) %>% dim() %>% .[1]
  pc<-pc$x[,1:sign_var] %>% data.frame()
  
  
 if (class(ds_original)=="data.frame"){
   pc$PriceEURO<-ds_original$PriceEURO
 } else {
   pc$PriceEURO<-PriceEURO
 }
  
  
  if (request=="summary"){
    lm_pc=pc %>% lm(log(PriceEURO)~.,.)
    lm_pc %>% summary() %>% return()
    
    
  } else if (request=="tree"){
  tree_constructor(pc)


  }else if (request=="rf") {
  rf_model(pc,"Whatever")
    } else {
    set.seed(1)
  
  index <- sample(2, nrow(pc), prob = c(0.8, 0.2), replace = TRUE) #so we give to each observation a prob of 80% of falling into the train and 20% of falling into the test

  Train <- pc[index==1, ] # Train data
  Test <- pc[index==2, ]
  lm_pc=Train %>% lm(log(PriceEURO)~.,.)
  yhat <- predict(lm_pc, newdata=Test)
  
  #in this case you return the R^2
  return(1-(
        (sum((log(Test$PriceEURO)-yhat)^2))/
        (sum((log(Test$PriceEURO)-mean(log(Test$PriceEURO)))^2))))
  }
  
}
```



```{r}
pr_lm(mec_statBR2, mec_statBR,"tree")
pr_lm(mec_statKW2, mec_statKW,"tree")
pr_lm(mec_statQT2, mec_statQT,"tree")
pr_lm(mec_statOM2, mec_statOM,"tree")
pr_lm(mec_statSA2, mec_statSA,"tree")
pr_lm(mec_statUAE2, mec_statUAE,"tree")
```


```{r}
pr_lm(mec_statBR2, mec_statBR,"summary")
pr_lm(mec_statKW2, mec_statKW,"summary")
pr_lm(mec_statQT2, mec_statQT,"summary")
pr_lm(mec_statOM2, mec_statOM,"summary")
pr_lm(mec_statSA2, mec_statSA,"summary")
pr_lm(mec_statUAE2, mec_statUAE,"summary")
```


```{r}
R2pr_lm<- c(pr_lm(mec_statBR2, mec_statBR),
pr_lm(mec_statKW2, mec_statKW),
pr_lm(mec_statQT2, mec_statQT),
pr_lm(mec_statOM2, mec_statOM),
pr_lm(mec_statSA2, mec_statSA),
pr_lm(mec_statUAE2, mec_statUAE))
R2pr_lm
```


```{r}
mec_map5 <- data.frame(region=c("Bahrain", "Kuwait", "Qatar", "Oman", "Saudi Arabia", "United Arab Emirates"),
                       R2pc_lm=R2pr_lm)

mapdata<-map_data("world")
mapdata <- left_join(mapdata, mec_map5, by="region") 
mapdata<-mapdata %>% filter(!is.na(mapdata$R2pc_lm))

ggplot(mapdata, aes(x=long, y=lat, group=group))+
  geom_polygon(aes(fill=R2pc_lm), color="black")+
  scale_fill_gradient(name="R¬≤ for the linear model run on\nthe significant PCs\n", low="#CCFFFF", high="#000066",
                      limit=c(.82, .87),
                      breaks=seq(from=.82,
                                 to=.87,
                            by=.01))+
  
  theme(axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks = element_blank(),
        axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        rect = element_blank())
```


```{r}
R2df$R2pca<-R2pr_lm

R2df <- R2df %>% select("region", "R2Tree", "R2rr", "R2pca", "R2rf", "R2best_Tr_rr")
R2df
```


```{r}
pr_lm(mec_statBR2, mec_statBR,"rf")
pr_lm(mec_statKW2, mec_statKW,"rf")
pr_lm(mec_statQT2, mec_statQT,"rf")
pr_lm(mec_statOM2, mec_statOM,"rf")
pr_lm(mec_statSA2, mec_statSA,"rf")
pr_lm(mec_statUAE2, mec_statUAE,"rf")
```


## Analysis of the entire dataset!


```{r}
mec_stat %>% select(-Horsepower, -Engine_Capacity) %>% tree_constructor()
```


I created a new function so that I re inserted the variable Area in the dataset. Not the smartest thing to do but it works.

```{r}
rob_reg1<-function(ds){
  set.seed(1)
  index <- sample(2, nrow(ds), prob = c(0.8, 0.2), replace = TRUE) 
  #so we give to each observation a prob of 80% of falling into the train and 20% of falling into the test
  
  PriceEURO<-ds$PriceEURO
  Area_<-ds$Area
  
  
  # difference with the rob_reg function !!
  ds<-ds %>% select(where(is.numeric), -PriceEURO) %>% scale() %>% data.frame() %>% cbind(PriceEURO)
  ds<- ds %>% cbind(Area_)
  
  Train <- ds[index==1, ] # Train data
  Test <- ds[index == 2, ] #Test data
  model1<- Train %>% lmrob(log(PriceEURO)~.,.)
  predicted<-predict(model1, newdata=Test)
  cat("\nR¬≤: ", 
      1-(
        (sum((log(Test$PriceEURO)-predicted)^2))/
          (sum((log(Test$PriceEURO)-mean(log(Test$PriceEURO)))^2))),"\n")
  model1 %>% summary() %>% print()
  model1$coefficients %>% sort(decreasing = TRUE)
}
```


```{r}
mec_stat %>% select(-Horsepower, -Engine_Capacity) %>% rob_reg1()
```


```{r}
mec_stat %>% select(-Horsepower, -Engine_Capacity) %>% rf_model(., "Big dataset")
```


```{r}
pcBR<- cbind(mec_statBR2, mec_statBR$PriceEURO)
pcBR$Area<-0
pcBR<-pcBR %>% rename("PriceEURO"="mec_statBR$PriceEURO")


pcKW<-cbind(mec_statKW2, mec_statKW$PriceEURO)
pcKW$Area<-1
pcKW<-pcKW %>% rename("PriceEURO"="mec_statKW$PriceEURO")

pcQT<-cbind(mec_statQT2, mec_statQT$PriceEURO)
pcQT$Area<-2
pcQT<-pcQT %>% rename("PriceEURO"="mec_statQT$PriceEURO")

pcOM<-cbind(mec_statOM2, mec_statOM$PriceEURO)
pcOM$Area<-3
pcOM<-pcOM %>% rename("PriceEURO"="mec_statOM$PriceEURO")

pcSA<-cbind(mec_statSA2, mec_statSA$PriceEURO)
pcSA$Area<-4
pcSA<-pcSA %>% rename("PriceEURO"="mec_statSA$PriceEURO")

pcUAE<-cbind(mec_statUAE2, mec_statUAE$PriceEURO)
pcUAE$Area<-5
pcUAE<-pcUAE %>% rename("PriceEURO"="mec_statUAE$PriceEURO")

mec_statPC <- rbind(pcBR, pcKW, pcQT, pcOM,pcSA,pcUAE)

```


```{r}
mec_statPC %>% pr_lm(.,0,request="default")
```


```{r}
mec_statPC %>% pr_lm(.,0,request="tree")
```


```{r}
mec_statPC %>% pr_lm(.,0,request="rf")
```

```{r}
pca(mec_statPC %>% select(-Horsepower, - Engine_Capacity, -PriceEURO), "General model")
```



```{r}
mec_statPC %>% select(-Horsepower, - Engine_Capacity, -PriceEURO) %>% prcomp(scale. = TRUE, center = TRUE) %>% fviz_eig(choice = "variance",addlabels=TRUE,xlab = "Principal components",
                  main = "" ,ylab = "",ncp=7,barfill = "deepskyblue", linecolor = "blue") + theme_minimal()
```

